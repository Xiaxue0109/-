

[TOC]

# 数据结构

###  程序 = 算法 + 数据结构

###  数据结构 = 结构定义 + 结构操作

#### 数据结构的分类：

1. 数据结构**按数据元素之间的关系**不同，可分四种：

> 1.1 集合结构    1.2 线性结构   1.3 树形结构   1.4 图形结构

2. 数据结构**按存储方式**不同，分为两种：

> 2.1 顺序存储结构（顺序表、栈、队列）

> 2.2 链式存储结构（每一个元素里设置了一个指针 指向 另一个存储地址）

3. 数据结构**按逻辑**分，两种： 线性结构 和 非线性结构 

#### 算法（algorithm）的特征：

1. 有穷性  2. 确定性  3. 可行性  4. 输入项  5. 输出项 

## 线性结构：

### 	线性表：

#### 		1. 从逻辑上看，线性表中的元素是按**顺序依次排列**的

#### 						2. 线性表中，**所有**元素的**数据类型**都是**相同**的

###  一、顺序表

 知识点：

1. **顺序表是存储结构**，用一组地址连续的存储单元依次存储数据元素，如果两个元素逻辑上是相邻的，则物理位置也是相邻的
2. 在顺序表中，元素都是一个挨一个的，元素集中在一段区间内，相对**存储密度大**
3. 为了保持逻辑上和物理上的连续性，顺序表在**插入和删除**操作时，会进行大量的数据移动，会**增加**操作的时间复杂度
4. 顺序表在**访问**元素时，可以通过**表头元素的地址**和**元素的编号（下标）**在**O（1）**时间内访问到它

（连续的存储空间）size, length, data_type = xxx;

#### （一）、顺序表定义：

1. 元素是**任意类型**的     eg：int * ,double * ,char **
2. data 数据      size大小       length长度;

####  （二）、顺序表操作：

+ 顺序表插入: **insert(loc, value)**   ; 将value值 插入到顺序表中下标为loc 的位置

  > 1. 判断插入的位置是否合法
  > 2. 判断顺序表是否已满
  > 3. 将目标位置及之后的元素后移一位
  > 4. 将带插入的元素插入到目标位置

+ 顺序表扩容: **expand()** ;  扩大顺序表的容量

  > 1. 将原来的元素存储到临时存储空间。
  > 2. 扩大原来的存储空间。
  > 3. 将临时存储空间里的数据元素复制到新的存储空间里。
  > 4. 释放临时的存储空间。

+ 顺序表查找：**search(value)**;  寻找顺序表中值为value的元素

  >1. 从下标为 0 的元素开始依次枚举顺序表中的所有元素。
  >2. 发现和目标值相等的元素则返回它的下标。
  >3. 枚举结束没有找到目标元素则返回 -1。

+ 顺序表删除：**remove(index)**;  将顺序表中下标为index的元素移除

  >1. 判断传入的参数是否合法，即下标是否在顺序表的范围内。
  >2. 将目标下标之后所有的元素前移一位。
  >3. 更新顺序表的长度。

插入操作：![1583074073205](/tmp/1583074073205.png)

![1583074048870](/tmp/1583074048870.png)

删除操作：![1583074136659](/tmp/1583074136659.png)

![1583074160498](/tmp/1583074160498.png)

#### （三）、顺序表代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//顺序表定义
typedef struct Vector {
    int *data;
    int size, length;
} Vector;

//顺序表初始化
Vector *init(Vector *vec, int n) {
    vec->data = (Vector *)malloc(sizeof(Vector));
    vec->size = n;
    vec->length = 0;
    return vec;
}
//扩容
int expand (Vector *vec) {
    int extr_size = vec->size;
    int *p;
    while (extr_size) {
        p = (int *)realloc(vec->data, sizeof(int) * (vec->size + extr_size));
        if (p) break;
        extr_size /= 2;
    }
    if (p == NULL) return 0;//扩容失败
    vec->size = p;
    vec->size += extr_size;
    return 1;
}
//顺序表插入
int insert(Vector *vec, int loc, int value) {
    if (vec == NULL) return 0;
    if (loc < 0 || loc > vec->length) return 0;
    if (vec->length == vec->size) {
        if (!expand(vec)) return 0;
        printf("expand success! size = %d\n", vec->size);
    }
    for (int i = vec->length; i > loc; i--) {
        vec->data[i] = vec->data[i - 1];
    }
    vec->data[loc] = value;
    vec->length++;
    return 1;
}

//顺序表的删除
int erase(Vector *vec, int index) {
    if (vec == NULL) return 0;
    if (index < 0 || index >= vec->lengtth) return 0;
    for (int i = index + 1; i < vec->length; i++) {
        vec->data[i - 1] = vec->data[i];
    }
    vec->length--;
    rerturn 1;
}

//打印输出
void output(Vector *vec) {
    printf("Vector(%d) = [", vec->length);
    for (int i = 0; i < vec->length; i++) {
        i && printf(", ");
        printf("%d", vec->data[i]);
    }
    printf("]\n");
    return ;
}

//顺序表的清空
void clear(Vector *vec) {
    if (vec == NULL) retrun ;
    free(vec->data);
    free(vec);
    return ;
}

int main() {
    #define max_op 20
    srand(time(0));
    Vector *vec = init(1);
    int op, index, value;
    for (int i = 0; i < max_op; i++) {
        op = rand() % 4;
        index = rand() % (vec->length + 3) - 1;
        val = rand() % 100;
        switch (op) {
            case 0: 
            case 1:
            case 2: {
                printf("insert %d to %d = %d\n", val, index, insert(vec, index, val));
            }
            case 3: {
                printf("erase item at %d from Vector = %d\n", ind, erase(vec, index));
            }
        }
    }
    
    
    return 0;
}
```



### 二、链表

（**链表**相当于**火车**；**火车头**相当于**表头**； 每节**车厢**就相当于链表的**元素**；车厢里边的**人和物**相当于**数据域**；**连接车厢的部件**相当于**元素的指针**）

知识点：

1. 元素不能随机访问，因为链表是串联的，在内存中不一定是顺序存储的
2. 元素相互依赖，串联而成；前一个链接后一个元素

#### （一）、链表的定义：**程序内部**（链表） 和 **内存内部**（节点）

能看到的链表：是head指针（首地址） 是程序内部的   

链表主要体现**内存内部**  是**节点信息**：节点分两部分 数据域 和 指针域

![1583074212908](/tmp/1583074212908.png)

链表的结构定义： 分两部分，一个是**节点定义**，另一个是**链表定义**， 其中链表定义中的head头结点是**虚拟头结点**（目的：插入或删除时，都需要找到插入或删除的前一个位置，当插入位置为0时，没办法找到前一个位置）

#### （二）、链表的操作：

+ 链表插入：**insert(node, index);**将node插入到链表下标为index的位置

  > 1. 找到链表中要插入的位置。
  > 2. **令待插入结点的 next 指针指向插入位置的当前结点。**
  > 3. **令插入位置之前的当前结点的 next 指针指向待插入结点。**


![1583074260426](/tmp/1583074260426.png)

![1583074303755](/tmp/1583074303755.png)

![1583074318520](/tmp/1583074318520.png)

![1583074349242](/tmp/1583074349242.png)

+ 链表删除：**delete_node(index)** ; 将链表中下标为index的元素删除

  > 1. 从表头遍历找到要删除的位置。
  > 2. 令删除位置前一个结点的next指针指向待删除位置后一个结点。
  > 3. 删除结点。

+ 链表翻转：**reverse()** ; 

  > 1. 定义一个用于遍历的指针，初始指向头结点后一个结点。
  > 2. 让头结点的 next 指针置空。
  > 3. 从当前遍历指针所指的结点开始遍历链表，将遍历到的结点 next 指针指向头结点。遍历过程中借助另外一个指针保存下一个遍历到的结点。
  > 4. 重复步骤 3 直至表尾，此时新的链表就是原链表反转后的链表。



#### （三）、链表代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//链表结点定义
typedef struct ListNode {
    int data;	//节点的数据域
    struct ListNode *next;	//节点的指针域
} ListNode;

//链表定义
typedef struct List {
    ListNode head;  //虚拟头结点
    int length;		//记录链表长度
} List;

//链表结点初始化
ListNode *getNewNode(int val) {
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));
    p->data = val;		
    p->next = NULL;
    return p;
}

//链表初始化
List *getLinkList() {
    List *l = (List *)malloc(sizeof(List));
    l->head.next = NULL;
    l->length = 0;
    return l;
}

//链表插入
int insert(List *l, int ind, int val) {
    if (l == NULL) return 0;	//链表为空
    if (ind < 0 || ind > l->length) return 0;	//待插入的位置不合适
    ListNode *p = &(l->head), *node = getNewNode(val);
    while (ind--) p = p->next;
    node->next = p->next;		//p的后节点 给 node
    p->next = node;				//node 给 p 的后继
    l->length += 1;
    return 1;
}

//链表删除
int erase(List *l, int ind) {
    if (l == NULL) return 0;
    if (ind < 0 || ind >= l->length) return 0;
    ListNode *p = &(l->head), *q;
    while (ind--) p = p->next;
    q = p->next;
    p->next = q->next;
    free(q);
    l->length -= 1;
    return 1;
}

//链表打印输出
void output(List *l) {
    printf("List(%d) = [", l->length);
    for (ListNode *p = l->head.next; p; p = p->next) {
        printf("%d->", p->data);
    }
    printf("NULL]\n");
    return ;
}

//链表翻转（头插法）
void rev(List *l) {
    if (l == NULL) return ;
    ListNode *p = l->head.next, *q;
    l->head.next = NULL;
    while (p) {
        q = p->next;
        p->next = l->head.next;
        l->head.next = p;
        p = q;
    }
    return ;
}

//链表结点释放
void clear_ListNode(ListNode *node) {
    if (node == NULL) return ;
    free(node);
    return ;
}

//链表清空释放
void clear_list(List *l) {
    if (l == NULL) return ;
    ListNode *p = l->head.next, *q;
    while (p) {
        q = p->next;
        clear_ListNode(p);
        p = q;
    }
    free(l);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    List *l = getLinkList();
    int op, ind, val;
    for (int i = 0; i < max_op; i++) {
        op = rand() % 4;
        ind = rand() % (l->length + 3) - 1;
        val = rand() % 100;
        switch (op) {
            case 0:
            case 1: {
                printf("insert %d at %d to List = %d\n", val, ind, insert(l, ind, val));
            } break;
            case 2: {
                printf("reverse the list\n");
                rev(l);
            } break;
            case 3: {
                printf("erase item at %d from List = %d\n", ind, erase(l, ind));
            } break;
        }
        output(l);
        printf("\n");
    }
    clear_list(l);
    return 0;
}
```



### 三、队列 （先进先出FIFO）

#### （一）、队列结构定义：

1.  头指针 head 
2.  尾指针  tail  
3.  队列大小 size  
4.  队中已有元素个数 count  

![1583074440949](/tmp/1583074440949.png)

#### （二）、队列操作：

+ 入队：

  > 1. 判断队列是否已满。实际上是由于队尾标记不断增加，需要判断队尾标记是否大于数组长度。
  > 2. 更新队尾标记，将新插入元素存入队尾。


![1583074485794](/tmp/1583074485794.png)

![1583074503631](/tmp/1583074503631.png)

+ 遍历：

  > 1. 输出队首标记所在的元素。
  > 2. 队首标记后移一位。
  > 3. 若队尾标记和队首标记相等，输出最后一个元素，否则返回步骤 1。

+ 出队：

  > 1. 比较队尾标记和队首标记的大小，当队首标记大于队尾标记则说明队列为空了，此时出队操作是非法的。
  > 2. 令队首标记后移一位，队首标记后移即视作原队首出队了。

+ 扩容 ：

  > 1. 先定义一个额外的空间 ， 再定义一个*p指针
  > 2. 用malloc扩容 size+ extra_size
  > 3. 如果失败0就跳出，不是就每次开原来的一半
  > 4. i 从队头开始，j = 0 ，j 到 count, j++.p[j]  =  q->data[(i + j) % q->size]; 

+ 判空  q->count  == 0

+ 输出头指针元素: q->data[q->head]

#### （三）、队列代码（循环队列）：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Queue {
    int *data;
    int head, tail, size, count;
} Queue;

//队列初始化
Queue *init(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->data = (int *)malloc(sizeof(int) * n);
    q->size = n;
    q->head = q->tail = q->count = 0;
}

//判空
int empty(Queue *q) {
    return q->count == 0; 
}

//输出头指针元素
int front(Queue *q) {
    if (empty(q)) return 0;
    return q->data[q->head];
}

//入队
int push(Queue *q, int val) {
    if (q == NULL) return 0;
    if (q->count == q->size) return 0;
    q->data[q->tail++] = val; // 尾指针+1，将值给尾指针
    if (q->tail == q->size) q->tail -= q->size; //防止假溢出
    q->count += 1; //元素个数多一个
    return 1;
}

//出队
int pop(Queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    q->head += 1;
    if (q->head == q->size) q->head -= q->size;
    q->count -= 1;
    return 1;
}

//输出打印
void output(Queue *q) {
    printf("Queue(%d) = [", q->count);  //count 是队列中元素个数
    for (int i = q->head, j = 0; j < q->count; j++) {
        j && printf(", ");
        printf("%d", q->data[(i + j) % (q->size)]);
        // 循环队列的下标超过，就对%长度  （重点）
    }
    printf("]\n");
    return ;
}

//释放队列
void clear(Queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0)); //随机,保证每次随机数据不相同
    #define max_op 20
    int op, val;
    Queue *q = init(max_op);
    for (int i = 0; i < max_op; i++) {
        op = rand() % 4; //75% 入队 ，25% 出队
        val = rand() % 100;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to Queue = %d\n", val, push(q, val));
            } break;
            case 3: {
                printf("pop %d from Queue = %d\n", front(q), pop(q));
            } break;
        }
        output(q);
        printf("\n");
    }
    clear(q);
    return 0;
}

```



### 四、栈 （先进后出FILO）

**解决完全包含关系的问题** （通常和树结合用）

#### （一）、栈定义：

1. 数据 ： data
2. 栈顶指针：top = -1
3. 栈的大小：size

#### （二）、栈操作：

+ 入栈：

  > 1. 判断栈是否已满，能否继续插入元素。
  > 2. 栈顶标记后移一位。
  > 3. 把新元素插入到当前栈顶标记的位置。


![1582389039787](/tmp/1583074578387.png)

+ 出栈：

  > 1. 判断是否是空栈
  > 2. 栈顶元素 - 1


![1583074561336](/tmp/1583074561336.png)

+ 扩容：

  > 1. 定义一个额外的空间 = 原来大小
  > 2. 定义一个 *p指针变量， 去开辟一片连续存储空间，如果2倍存不下就开2倍的一半实在开不了就退出，能开辟就再加上额外的空间

+ 判空： 栈顶 == -1

+ 输出栈顶元素

应用：1. 将数据进行倒排   2. 表达式求值问题 （计蒜客）

系统栈也是栈， **调用函数**就是用的系统栈  系统栈8MB

#### （三）、栈代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Stack {
    int *data;
    int top, size;
} Stack;

//初始化
Stack *init(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s->data = (int *)malloc(sizeof(int) * n);
    s->top = -1;
    s->size = n;
    return s;
}

//判空
int empty(Stack *s) {
    return s->top == -1;
}

//输出栈顶元素
int top(Stack *s) {
    return s->data[s->top];
}

//扩容
int expand(Stack *s) {
    int extr_size = s->size;
    int *p;
    while (extr_size) {
        p = (int *)realloc(s->data, sizeof(int) * (s->size + extr_size));
        if (p) break;
        extr_size /= 2;
    }
    if (p == NULL) return 0;
    s->size += extr_size;
    s->data = p;
    return 1;
}

//入栈
int push(Stack *s, int val) {
    if (s == NULL) return 0;
    if (s->top + 1 == s->size) {
        if (!expand(s)) return 0;
        printf("expand successful! size = %d\n", s->size);
    }
    s->top += 1;
    s->data[s->top] = val;
    return 1;
}

//出栈
int pop(Stack *s) {
    if (s == NULL) return 0;
    if (empty(s)) return 0;
    s->top -= 1;
    return 1;
}

//输出栈所有元素
void output (Stack *s) {
    printf("Stack(%d) = [", s->top + 1);
    for (int i = 0; i <= s->top; i++) {
        i && printf(", ");
        printf("%d", s->data[i]);
    }
    printf("]\n");
    return ;
}

//释放
void clear(Stack *s) {
    if (s == NULL) return ;
    free(s->data);
    free(s);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int op, val;
    Stack *s = init(5);
    for (int i = 0; i < max_op; i++) {
        op = rand() % 4;
        val = rand() % 100;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to Stack = %d\n", val, push(s, val));
            } break;
            case 3: {
                printf("pop %d to Stack = %d\n", top(s), pop(s));
            }
        }
        output(s);
        printf("\n");
    }
    clear(s);
    return 0;
}

```

栈和队列的应用：

​	栈 ：树的深层遍历、深度优先搜索（图算法基础）

​	队列（循环）： 树的层次遍历、广度优先搜索

​	单调栈： 临近最大值（小）值

​	单调队列： 区间最大（小）值

​		RMQ问题：RMQ（x , y）x 到 y 区间的最大（小）值   （滑动窗口）

## 非线性结构

### 一、树  （完全包含的数据结构）

根结点 和 子结点

节点   ------>   集合

边        ----->   对应关系 ![1582389190446](/tmp/1583074641304.png)

#### （一）、**树的结构定义**：

（链表是特殊的树）链表定义*next[n]

树的深度 、高度： 深度（从上 -> 下）高度（从下 - > 上）

树的度：出去的边数

**节点的数量  =  边数  +  1；**

![1583074803628](/tmp/1583074803628.png)

#### （二）、二叉树：

1. 每个节点度最多为2

2. 度为0的节点 比 度为2的节点 多一个

   公式：节点n0 + n1 + n2 =  边  n1 + 2 * n2  + 1

    所以   **n0 = n2 + 1;**

3. **二叉树第 i 层最多有 2^(i - 1) 个结点**

4. **深度为k 的二叉树最多有2^k - 1 个结点**

N叉树是不确定问题不确定树，二叉树是确定问题确定树

N叉树  转换成  二叉树  用**左孩子 右兄弟** 方法  就叫**十字链表法**

###### 2.1.  二叉树结构定义：

1. 节点定义

   > 1. 数据： data
   > 2. 节点定义: 左孩子 ：lchild 右孩子：rchild

2. 树定义 : 根结点 root ，树的节点 n 

###### 2.2.  **二叉树的三种遍历**：

+ 前序遍历： 根   左    右
+ 中序遍历： 左   根    右
+ 后续遍历： 左   右    根

![1583074784255](/tmp/1583074784255.png)

###### 2.3.  **二叉树分类**： 完全二叉树  和  满二叉树

​	完全二叉树：只有唯一个节点有左孩子 **只会少一个 *右孩子* ** 

​	满二叉树 ： 全是有两个叉的树

   	完全二叉树特点： 1. 编号为i的子结点 ， 左孩子的编号 2 * i，  右孩子的编号 2 * i + 1 。2. 可以用连续空间存储（数组）

![1583074831710](/tmp/1583074831710.png)

![1583074871575](/tmp/1583074871575.png)

###### 2.4.  二叉树代码(先中后序遍历，以广义表形式输出)：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//节点定义
typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
}Node;

typedef struct Tree {
    Node *root;
    int n;
} Tree;

//节点初始化
Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->lchild = p->rchild = NULL;
    return p;
}

Tree *getNewTree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}

Node *insertNode(Node *root, int val, int *ret) {
    if (root == NULL) {
        *ret = 1;
        return getNewNode(val);
    }
    if (root->data == val) return root;
    if (val < root->data) root->lchild = insertNode(root->lchild, val, ret);
    else root->rchild = insertNode(root->rchild, val, ret);
    return root;
}

void insert(Tree *tree, int val) {
    int flag = 0;
    tree->root = insertNode(tree->root, val, &flag);
    tree->n += flag;
    return ;
}

void in_orderNode(Node *node) {
    if (node == NULL) return ;
    in_orderNode(node->lchild);
    printf("%d ", node->data);
    in_orderNode(node->rchild);
    return ;
}

void in_order(Tree *tree) {
    printf("in_order(%d) = ", tree->n);
    in_orderNode(tree->root);
    printf("\n");
    return ;
}

void pre_orderNode(Node *node) {
    if (node == NULL) return ;
    printf("%d ", node->data);
    pre_orderNode(node->lchild);
    pre_orderNode(node->rchild);
    return ;
}

void pre_order(Tree *tree) {
    printf("pre_order(%d) = ", tree->n);
    pre_orderNode(tree->root);
    printf("\n");
    return ;
}

void post_orderNode(Node *node) {
    if (node == NULL) return ;
    post_orderNode(node->lchild);
    post_orderNode(node->rchild);
    printf("%d ", node->data);
    return ;
}

void post_order(Tree *tree) {
    printf("post_order(%d) = ", tree->n);
    post_orderNode(tree->root);
    printf("\n");
    return ;
}

void clear_Node(Node *node) {
    if (node == NULL) return ;
    clear_Node(node->lchild);
    clear_Node(node->rchild);
    free(node);
    return ;
}

void clear_tree(Tree *tree) {
    if (tree == NULL) return ;
    clear_Node(tree->root);
    free(tree);
    return ;
}

void outputNode(Node *root) {
    if (root == NULL) return ;
    printf("%d", root->data);
    if (root->lchild == NULL && root->rchild == NULL) return ;
    printf("(");
    outputNode(root->lchild);
    printf(",");
    outputNode(root->rchild);
    printf(")");
    return ;
}

void output(Tree *tree) {
    if (tree == NULL) return ;
    printf("tree(%d) = ", tree->n);
    outputNode(tree->root);
    printf("\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 10
    Tree *tree = getNewTree();
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        insert(tree, val);
        output(tree);
    }
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    clear_tree(tree);
    return 0;
}
```

###### 2.5.  二叉树 ----- 广义表 

![1583074927359](/tmp/1583074927359.png)

###### 2.6.  用广义表创建二叉树的伪代码：

> 设置一个标记变量 k，初始为 -1；
> 设置一个标记节点 p；
> 循环遍历存储广义表的字符串 str：
>     如果 str[i] 是左括号：
>         则设置 k 为 0；
>         把 p 压入栈中。
>     否则如果 str[i] 是逗号：
>         则设置 k 为 1。
>     否则如果 str[i] 是右括号：
>         则栈顶元素出栈。
>     否则如果 str[i] 是一个字母，用节点 temp 来存储：
>         如果 k 为 -1：
>             则把 temp 作为根节点并压入栈中。
>         如果 k 为 0：
>             如果此时栈顶节点是 p，则先出栈；
>             然后将 temp 作为栈顶节点的左孩子；
>             再把 temp 压入栈中。
>         如果 k 为 1：
>             栈顶元素出栈；
>             将 temp 作为栈顶节点的右孩子；
>             再把 temp 压入栈中。

###### 2.7.  广义表转二叉树代码（先中后序遍历输出）：

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char data;
    struct Node *lchild, *rchild;
} Node;

typedef struct Tree {
    Node *root;
    int n;
} Tree;

Node *getNewNode(char val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->lchild = p->rchild = NULL;
    return p;
}

Tree *getNewTree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}

typedef struct Stack {
    Node **data;
    int top, size;
} Stack;

Stack *init_stack(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s->data = (Node **)malloc(sizeof(Node *) * n);
    s->top = -1;
    s->size = n;
    return s;
}

int empty(Stack *s) {
    return s->top == -1;
}

Node *top(Stack *s) {
    return s->data[s->top];
}

int push(Stack *s, Node *val) {
    if (s == NULL) return 0;
    if (s->top == s->size - 1) return 0;
    s->data[++(s->top)] = val;
    return 1;
}

int pop(Stack *s) {
    if (empty(s)) return 0;
    s->top -= 1;
    return 1;
}

void clear_stack(Stack *s);

Node *build(char *str, int *node_num) {
    Node *temp = NULL, *p = NULL;
    Stack *s = init_stack(strlen(str));
    int flag = 0;
    while (str[0]) {
        switch (str[0]) {
            case '(':
                push(s, temp);
                flag = 0;
                temp = NULL;
                break;
            case ')':
                p = top(s);
                pop(s);
                break;
            case ',':
                flag = 1;
                temp = NULL;
                break;
            case ' ':
                break;
            default:
                temp = getNewNode(str[0]);
            if (!empty(s) && flag == 0) {
                top(s)->lchild = temp;                                
            } else if (!empty(s) && flag == 1) {
                top(s)->rchild = temp;                                
            }
            ++(*node_num);
            break;    
        }
        ++str;    
    }
    clear_stack(s);
    if (temp && !p) p = temp;
    return p;
}

void in_orderNode(Node *node) {
    if (node == NULL) return ;
    in_orderNode(node->lchild);
    printf("%c ", node->data);
    in_orderNode(node->rchild);
    return ;
}

void in_order(Tree *tree) {
    printf("in_order : ");
    in_orderNode(tree->root);
    return ;
}

void pre_orderNode(Node *node) {
    if (node == NULL) return ;
    printf("%c ", node->data);
    pre_orderNode(node->lchild);
    pre_orderNode(node->rchild);
    return ;
}

void pre_order(Tree *tree) {
    printf("pre_order : ");
    pre_orderNode(tree->root);
    return ;
}

void post_orderNode(Node *node) {
    if (node == NULL) return ;
    post_orderNode(node->lchild);
    post_orderNode(node->rchild);
    printf("%c ", node->data);
    return ;
}

void post_order(Tree *tree) {
    printf("post_order : ");
    post_orderNode(tree->root);
    return ;
}
void clear_node(Node *node) {
    if (node == NULL) return ;
    clear_node(node->lchild);
    clear_node(node->rchild);
    return ;
}

void clear_tree(Tree *tree) {
    if (tree == NULL) return ;
    clear_node(tree->root);
    free(tree);
    return ;
}

void clear_stack(Stack *s) {
    if (s == NULL) return ;
    free(s->data);
    free(s);
    return ;
}

int main() {
    char str[100];
    scanf("%[^\n]s", str);
    int node_num = 0;
    Tree *tree = getNewTree();
    tree->root = build(str, &node_num);
    tree->n = node_num;
    pre_order(tree), printf("\n");
    in_order(tree), printf("\n");
    post_order(tree), printf("\n");
    clear_tree(tree);
    return 0;
}

```

### 二、堆 （优先队列）

#### （一）、堆的操作：

**大顶堆就是完全二叉树的根结点都大于叶子结点**

![1583075021521](/tmp/1583075021521.png)

**完全二叉树中任意个叉（三角形）都满足 大顶堆/ 小顶堆**

+ 堆插入（堆--尾部插入调整）：

  + 从**队尾**插入，满足堆性质，**自下向上调整**

  > 1. 把新元素保存在数组的**最后**。
  > 2. 找到新插入元素的父节点位置。
  > 3. 将新元素与父节点比较大小。
  > 4. 若新插入的元素与其父节点大小不符合堆序性则交换它和父节点的位置，并回到步骤 2；若符合则插入操作完成。


![1583075047457](/tmp/1583075047457.png)

![1583075073872](/tmp/1583075073872.png)

![1583075087547](/tmp/1583075087547.png)

![1583075101606](/tmp/1583075101606.png)

+ 删除（弹出）堆顶元素：

  + 队首元素和最后一个元素交换，弹出**头部**，**自下向上调整**

  > 1. 将**堆顶**元素和**最后一个元素**交换。
  > 2. 删除堆的最后一个元素。
  > 3. 自顶向下调整元素的位置，使之满足堆序性。

![1583075128441](/tmp/1583075128441.png)

![1583075143495](/tmp/1583075143495.png)

![1583075163209](/tmp/1583075163209.png)

![1583075203833](/tmp/1583075203833.png)

+ 弹出堆中元素： heap->data[0]

#### （二）、堆排序：

######        大顶堆 排序后是  从 小 到 大 ，反之，小顶堆  排序后是  从 大 到 小

堆排序的算法如下：

> 1. 将变量 i 设为堆末下标。
> 2. 交换堆顶和第 i 个元素。
> 3. 自上到下调整堆顶到第 i 个元素之间的堆结构，使之保持堆序性。
> 4. 将 i 前移一位，重复步骤 2，直至 i 等于 1。

![1582389858578](/tmp/1583075224536.png)

![1583075257222](/tmp/1583075257222.png)

![1583075277973](/tmp/1583075277973.png)

#### （三）、堆 (优先队列) 和 队列的区别：

![1583075293914](/tmp/1583075293914.png)

#### （四）、堆（优先队列）代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct priority_queue {
    int *data;
    int cnt, size;
} priority_queue;

//初始化优先队列
priority_queue *init(int n) {
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * (n + 1));
    q->size = n;
    q->cnt = 0;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

//堆顶元素
int top(priority_queue *q) {
    return q->data[1];
}

//插入元素 （大顶堆）
int push(priority_queue *q, int val) {
    if (q->cnt == q->size) return 0;   //满了
    q->cnt += 1;
    q->data[q->cnt] = val;    //插入完成
    int ind = q->cnt;
    while (ind >> 1 && q->data[ind] > q->data[ind >> 1]) {
        swap(q->data[ind], q->data[ind >> 1]); //和父节点比较大小
        ind >>= 1;            
    }
    return 1;
}

//出堆
int pop(priority_queue *q) {
    if (empty(q)) return 0;
    swap(q->data[1], q->data[q->cnt]);  // 堆尾 和 堆首 互换
    q->cnt--;
    int ind = 1;
    while ((ind << 1) <= q->cnt) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (q->data[l] > q->data[temp]) temp = l;
        if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;
        if (temp == ind) break; // 满足三元组堆顺序
        swap(q->data[ind], q->data[temp]);
        ind = temp;
    }
    return 1;
}

void clear(priority_queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    priority_queue *q = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        push(q, val);
        printf("push %d to queue\n", val);            
    }
    for (int i = 0; i < max_op; i++) {
        printf("%d ", top(q));
        pop(q);    
    }
    printf("\n");
    for (int i = 1; i <= max_op; i++) {
        printf("%d ", q->data[i]);    
    }
    printf("\n");
    clear(q);
    return 0;
}

```

#### （五）、堆排序代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

//自上向下调整
void downUpdata(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {   //ind * 2
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}
//堆排序 （第1个for先让三元组有序， 第二个for是把堆首 和最后交换，放到后边， 再调整）
void heap_sort(int *arr, int n) {
    arr -= 1;    //arr[0]开始，arr存的地址， 指向的是-1， 实际用的还是
    for (int i = n >> 1; i >= 1; i--) {
        downUpdata(arr, n, i);
    }
    for (int i = n; i > 1; i--) {
        swap(arr[i], arr[1]);  //放在最后
        downUpdata(arr, i - 1, 1); //自上到下调整
    }
}

void output (int *arr, int n) {
    printf("arr(%d) = [", n);
    for (int i = 0; i < n; i++) {
        printf(" %d", arr[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int *arr = (int *)malloc(sizeof(int) * max_op);
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        arr[i] = val;
    }
    output(arr, max_op);
    heap_sort(arr, max_op);
    output(arr, max_op);
    free(arr);
    return 0;
}
```



## 排序算法

### 稳定排序：

#### （一）、插入排序  O(n^2)

+ 先将排序区分为 已排序区 和 待排序去区
+ 将  已排序区 后面的一个元素，向 **前边**插入到  待排序区 中
+ 直到待排序去没有元素为止

![1582295867830](/tmp/1583075384861.png)

![1582295899682](/tmp/1583075399219.png)

![1582295916299](/tmp/1583075411978.png)

![1583075434355](/tmp/1583075434355.png)

![1583075463379](/tmp/1583075463379.png)

#### （二）、冒泡排序 O(n^2)

+ 将数组分成 已排序区 和 待排序区
+ 从头到尾扫描待排序区， 若 **前边元素比后边元素大**，则交换
+ 每一轮会将待排序区中最大的放到 已排序区的开头
+ 直到待排序区没有元素为止

**优化版的增加了一个标记值times，是记录交换的次数的，如果times = 0 ，说明没有交换已经有序，就退出；**

![1583075525074](/tmp/1583075525074.png)

![1583075540955](/tmp/1583075540955.png)

![1583075556413](/tmp/1583075556413.png)

![1583075573397](/tmp/1583075573397.png)

![1583075584077](/tmp/1583075584077.png)

#### （三）、归并排序 O(nlogn)

+ 先将 原数组分成两部分（分治）
+ 不断将问题 划分， 划分成 两个元素一个元素
+ 然后调用原函数，将所分的区间进行排序
+ 再开辟一个新数组临时存放两个小数组比较后的结果， 载释放掉。

![1583075626542](/tmp/1583075626542.png)

![1583075652943](/tmp/1583075652943.png)

![1583075666685](/tmp/1583075666685.png)

![1583075681825](/tmp/1583075681825.png)

![1583075700786](/tmp/1583075700786.png)

![1583075712027](/tmp/1583075712027.png)



#### （四）、稳定排序代码

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define swap(a, b) {\
    a ^= b; b ^= a; a ^= b;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s = ",#func);\
    func(args);\
    output(num, n);\
    free(num);\
}

//插入排序
void insert(int *num, int n) {
    for (int i = 1; i < n - 1; i++) {
        for (int j = i; j > 0 && num[j] < num[j - 1]; j--) {
            swap(num[j], num[j - 1]);
        }
    }
    return ;
}

//冒泡排序
void bubble_sort (int *num, int n) {
    int times = 1;
    for (int i = 1; i < n && times; i++) {
        times = 0;
        for (int j = 0; j < n - i; j++) {
            if (num[j] > num[j + 1]) {
                swap(num[j], num[j + 1]);
                times++;
            }
        }
    }
    return ;
}

//归并排序
void merge_sort(int *num, int l, int r) {
    if (r - l <= 1) {							// 剩一个或两个元素
        if (r - l == 1 && num[l] > num[r]) {	// 两个元素，从小到大，顺序不符，交换
            swap(num[l], num[r]);
        }
        return ;
    }
    int mid = (l + r) >> 1;
    merge_sort(num, l, mid);   					//排序数组的前半部分
    merge_sort(num, mid + 1, r);				//排序数组的后半部分
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));	//开辟临时的空间
    int p1 = l, p2 = mid + 1, k = 0;			
    while (p1 <= mid || p2 <= r) {				// 有左边或者右边元素
        if (p2 > r || (p1 <= mid && num[p1] < num[p2])) {	//右边没有或者左边排好序的放里边
            temp[k++] = num[p1++];
        } else {
            temp[k++] = num[p2++];
        }
    }
    memcpy(num + l, temp, sizeof(int) * (r - l + 1));		//将temp数组里的存到num数组里
    free(temp);
    return ;
}

void randint(int *arr, int n) {
    while (n--) arr[n] = rand() % 100;			//随机函数
    return ;
}

void output(int *num, int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf(" %d", num[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int arr[max_op];
    randint(arr, max_op);
    TEST(arr, max_op, insert, num, max_op);
    TEST(arr, max_op, bubble_sort, num, max_op);
    TEST(arr, max_op, merge_sort, num, 0, max_op - 1);
    return 0;
}

```



### 非稳定排序

#### （一）、选择排序  O(n^2)

+ 将数组分成待排序区和已排序区
+ 每一轮从 待排序区中选择一个最小的元素放到已排序区的尾部
+ 直到待排序区没有元素为止

![1582295339966](/tmp/1583075808622.png)

练习题：![1582295599643](/tmp/1583075909449.png)

![1583075929927](/tmp/1583075929927.png)

![1583075951741](/tmp/1583075951741.png)

#### （二）、快速排序  O(nlogn)【最坏O(n^2)】

+ 先将第一个元素作为基准值
+ 有前后两个指针，后指针从后边找到第一个比基准值小的值，将小的值放到第一个元素
+ 再将前边指针后移，找到比基准值大的，放到刚才空出来的位置
+ 最后空出来的位置放基准值

![1582296298307](/tmp/1583075979248.png)

![1582296319752](/tmp/1583075995647.png)

![1582296339163](/tmp/1583076012403.png)

![1582296356047](/tmp/1583076026301.png)

![1582296385266](/tmp/1583076042942.png)

![1582296407263](/tmp/1583076068496.png)

![1583076084194](/tmp/1583076084194.png)

![1583076097125](/tmp/1583076097125.png)

![1583076116644](/tmp/1583076116644.png)

![1583076132659](/tmp/1583076132659.png)

![1583076144967](/tmp/1583076144967.png)

#### （三）、堆排序  O(nlogn)  希尔排序

​	相对比较排序，堆排序、归并排序等排序算法的效率更高

#### （四）、非稳定排序代码

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s = ", #func);\
    func(args);\
    output(num, n);\
    free(num);\
}

//选择排序
void select_sort(int *num, int n) {
    for (int i = 0; i < n - 1; i++) {
        int ind = i;
        for (int j = i + 1; j < n; j++) {
            if (num[ind] > num[j]) ind = j;
        }
        swap(num[i], num[ind]);
    }
    return ;
}

//快排
/*
void quick_sort(int *num, int l, int r) {
    if (r < l) return ;
    int x = l, y = r, z = num[l];
    while (x < y) {
        while (x < y && num[y] >= z) y--;
        if (x < y) num[x++] = num[y];
        while (x < y && num[x] <= z) x++;
        if (x < y) num[y--] = num[x];
    }
    num[x] = z;
    quick_sort(num, l, x - 1);
    quick_sort(num, x + 1, r);
    return ;
}
*/
//快排改进版
void quick_sort(int *num, int l, int r) {
    while (l < r) {
        int x = l, y = r, z = num[(l + r) >> 1];
        do {
            while (x <= y && num[x] < z) x++;
            while (x <= y && num[y] > z) y--;
            if (x <= y) {
                swap(num[x], num[y]);
                x++, y--;
            }
        } while (x <= y);
        quick_sort(num, x, r);
        r = y;
    }
}

void randint(int *arr, int n) {
    while (n--) arr[n] = rand() % 100;
    return ;
}

void output(int *num, int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf(" %d", num[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int arr[max_op];
    randint(arr, max_op);
    TEST(arr, max_op, select_sort, num, max_op);
    TEST(arr, max_op, quick_sort, num, 0, max_op - 1);
    return 0;
}

```

#### 宏定义的swap函数：

方法1 ：

```C
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}
//定义一个类型的a, 找个中间变量交换
```

方法2 ：

```C
#define swap(a, b) {\
    a ^= b; b ^= a; a ^= b;\
}
// 两个相同的值异或 第一次等于0，第二次值与0异或 等于值本身，第三次同第二次
// 同一地址的值异或是0，就异或不回去了
// n ^ 0 = n
```











## 查找算法

查找：是指在数据集合中寻找某种天剑的数据元素的过程。

查找表：用于查找的数据集合

查找表的4种操作：

1. 查找：在查找表中看某个特定的记录是否存在
2. 检索：查找某个特定记录的各种属性
3. 插入：在某个不存在的数据元素插入到查找表中
4. 删除：从查找表中删除某个特定的元素

对于查找表只执行前两种操作，称静态查找表，静态查找表建立后再执行后两种操作，称动态查找表

#### （一）、顺序查找  O(n)

顺序查找算法适用于顺序表、链表等线性的数据结构

#### （二）、折半(二分)查找  O(logn)

只能应用在**有序**的顺序表中

+ 如果待查找的值小于mid，将右指针移至mid - 1，反之，将左指针放到mid + 1,每次取得是区间的一半 

![1582299114077](/tmp/1583076274808.png)

特殊情况1：

![1582299707445](/tmp/1583076214052.png)

特殊情况2：

![1583076238628](/tmp/1583076238628.png)

#### （三）、三分查找   O(logn)

来解决凹凸函数求极值点的问题

三分查找每次比较后，都会将区间长度缩短到原来的2/3

![1582261976276](/tmp/1583076318124.png)



#### （四）、二分查找代码

```C
#include <stdio.h>
#define P(func, args...) {\
    printf("%s = %d\n", #func, func(args));\
}

int binary_search1(int *num, int n, int x) {
    int head = 0, tail = n - 1, mid;
    while (head <= tail) {
        mid = (head + tail) >> 1;
        if (num[mid] == x) return mid;
        if (num[mid] < x) head = mid + 1;
        else tail = mid - 1;
    }
    return -1; //表示没找到
}

// 11111111000000  找最后一个1
int binary_search2(int *num, int n) {
    int head = -1, tail = n - 1, mid;
    while (head < tail) {
        mid = (head + tail + 1) >> 1;
        if (num[mid] == 1) head = mid;
        else tail = mid - 1;
    }
    return head;
}

// 0000000111111  找第一个1
int binary_search3(int *num, int n) {
    int head = 0, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (num[mid] == 1) tail = mid;
        else head = mid + 1;
    }
    return head == n ? -1 : head;
}

int main() {
    int arr1[10] = {1, 3, 5, 7, 9, 11, 13, 17, 19, 23};
    int arr2[10] = {1, 1, 1, 1, 0, 0, 0, 0, 0, 0};
    int arr3[10] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1};
    P(binary_search1, arr1, 10, 7);
    P(binary_search2, arr2, 10);
    P(binary_search3, arr3, 10);
    return 0;
}

```



### 哈希表

#### （一）、哈希表定义：

+ 1.1 哈希表又叫散列表，关键值通过哈希函数一个射到数组上，查找时通过关键值直接访问数组。
+ 1.2 哈希函数指的是关键值和存储位置建立的对应关系，查找时只要根据这个关旭就能找到目标位置。一般通过一次查找就能找到目标位置
+ 1.3 哈希函数构造的好坏会影响查找效率
+ 1.4 某些问题里，哈希表里的冲突只能减少，是不可完全避免的

#### （二）、哈希函数的构造方法：

###### 1. 直接寻址法：

###### 2. 除留余数法：

设计哈希函数时要达到两个要求：

1. 计算简单， 计算复杂的哈希函数会增加查询的时间
2. 关键字尽可能均分到存储地址上，这样可以减少冲突

#### 2.1 **处理冲突的方法：**

1.  开放定值法
2.  **拉链法**
3. 再哈希法
4.  建立公共溢出区

线性探测法查找哈希表冲突的算法流程如下：

> 1. 用哈希函数找到字符串 S 的初始位置，初始化冲突次数。
> 2. 从当前位置往后查找，找到第一个未发生冲突的位置 K（当前位置上如果存储的字符串不是 S 即视为发生冲突）。查找过程中记录发生冲突的次数 T，如果 T 大于等于表长，则结束算法，表示查找失败。
> 3. 如果位置 K 上的元素就是所查找的字符串，表示查找成功，否则表示查找失败。

#### 2.2 哈希表重建操作的算法流程如下：

> 1. 开辟一段和当前哈希表等大的临时存储空间。
> 2. 将原哈希表里的关键字一一复制到临时数组里。
> 3. 申请一个大小是现在两倍的新的存储空间，释放原空间。
> 4. 将新空间里的存储地址初始化。
> 5. 将关键字从临时数组复制到新的空间，释放临时空间。

#### 2.3 哈希表代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char *str;
    struct Node *next;
}Node;

typedef struct HashTable {
    Node **data;
    int size;//存储空间大小
}HashTable;

Node *init_node(char *str, Node *head) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->str = strdup(str);
    p->next = head;
    return p;
}

HashTable *init_hashtable(int n) {
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    h->size = n << 1;
    h->data = (Node **)calloc(h->size, sizeof(Node *));//初始清空
    return h;
}

//哈希函数 处理字符串BKDR
int BKDRHash(char *str) {
    int seed = 31, hash = 0;
    for (int i = 0; str[i]; i++) hash = hash * seed + str[i];
    return hash & 0x7fffffff;
}

//哈希表插入
int insert(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    h->data[ind] = init_node(str, h->data[ind]);
    return 1;
}

//哈希表查找
int search (HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    Node *p = h->data[ind];
    while (p && strcmp(p->str, str)) p = p->next;
    return p != NULL;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    Node *p = node, *q;
    while (p) {
        q = p->next;
        free(p->str);
        free(p);
        p = q;
    }
    free(q);
    return ;
}

void clear_hashtable(HashTable *h) {
    if (h == NULL) return ;
    for (int i = 0; i < h->size; i++) clear_node(h->data[i]);
    free(h->data);
    free(h);
    return ;
}

int main() {
    int op;
    #define max_n 100
    char str[max_n + 5];
    HashTable *h = init_hashtable(max_n + 5);
    while (~scanf("%d %s", &op, str)) {
        switch (op) {
            case 0: {
                printf("insert %s to hash table\n", str);
                insert(h, str);
            }    break;
            case 1: {
                printf("search %s resule = %d\n", str, search(h, str));
            }    break;
        }
    }
    clear_hashtable(h);
    return 0;
}

```



### 二叉查找(搜索）树 

插入的时间复杂度：最坏O(n) ,  期望时间复杂度O(logn)

#### 1. 二叉查找树插入操作的算法流程如下：

 >1. 根节点为空则新元素直接作为根节点，否则传入的参数 value 与根节点进行比较。
 >2. value 等于当前节点则直接返回，小于则跳转到步骤 3，而如果 value 大于当前节点时，跳转到步骤 4。
 >3. 判断当前节点是否存在左孩子，如果存在则让其左孩子继续调用插入方法，回到步骤 2，如果不存在则将新元素插入到当前节点的左孩子位置上。
 >4. 判断当前节点是否存在右孩子，存在则让其右子树继续调用插入方法，回到步骤 2，不存在则将新元素插入到当前节点的右孩子位置上。

#### 2. 查找节点前驱的算法流程如下：

> 1. 找到当前节点的左孩子，如果当前节点没有左孩子则不存在前驱，若存在，则找到其左孩子的右孩子。
> 2. 若当前节点有右孩子则继续找到其右孩子，重复步骤 2，直至找到一个节点不存在右孩子时，那么它就是我们要查找的前驱。

#### 3. 删除操作的算法流程如下：

> 1. 如果当前节点仅存在左孩子，则更新左孩子的父节点为被删除节点的父节点。
> 2. 如果当前节点仅存在右孩子，则将其右孩子的父节点更新为被删除节点的父节点。
> 3. 更新被删除节点的父节点的孩子指针，使其原本指向被删除节点的指针指向被删除节点的孩子节点。

#### 4. 完整的删除操作的算法流程如下：

> 1. 找到被删除的节点。
> 2. 若它存在左孩子，则找到他的前驱，用前驱替换被删除节点的值，再调用删除节点的方法删除前驱。
> 3. 若被删除节点不存在左孩子，则找到它的后继，用后继替换被删除节点的值，再调用删除节点的方法删除后继。
> 4. 若被删除的节点不存在孩子节点，直接调用删除节点的的方法删除它。

#### 5.二叉查找树代码：

```C
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int key;
    struct Node *lchild, *rchild;
}Node;

Node *getNewNode (int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NULL;
    return p;
}

Node *insert(Node *root, int key) {
    if (root == NULL) return getNewNode(key);
    if (root->key == key) return root;
    if (key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->lchild) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int key) {
    if (root == NULL) return root;
    if (key < root->key) root->lchild = erase(root->lchild, key);
    else if(key > root->key) root->rchild = erase(root->rchild, key);
    else {
        if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp; //删除度为1的结点
        } else {
            Node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    return root;
}

void __in_order(Node *root) {
    if (root == NULL) return ;
    __in_order(root->lchild);
    printf("%d ", root->key);
    __in_order(root->rchild);
    return;
}

void in_order(Node *root) {
    printf("in order output : ");
    __in_order(root);
    printf("\n");
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

int main() {
    int op, val;
    Node *root = NULL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
        }
        in_order(root);
    }
    clear(root);
    return 0;
}

```



### 森林和并查集

森林没有中序遍历，只有先序和后序遍历

#### 1. 森林的先序遍历的规则：

+ 访问森林中第一棵树的根结点
+ 先序遍历森林中第一棵树的根结点的各子树所构成的森林
+ 先序遍历森林中，除第一棵树外其余树构成的森林

#### 2. 森林的后序遍历的规则：

+ 后序遍历森林中的第一棵树的根结点的各子树所构成的森林
+ 访问森林中第一棵树的根结点
+ 后序遍历森林中除第一棵树外其余树构成的森林

#### 3. 并查集(不相交集合)

是用于解决若干的不相交集合的如下几种操作的统称：

1. MAKE-SET(x): 初始化操作，建立一个只包含x的集合
2. UNION(x, y): 合并操作，将x和y的集合合并为一个新的集合
3. FIND-SET(x): 查询操作，计算x所在的集合

”并查集“ 既可以指代不相交集合的数据结构，也可以表示对应其算法。(Disjoint Set Union)

并查集的最坏时间复杂度是 O(N)

#### 4. 并查集的操作：

1. 并查集查询操作：

   > 1. 寻找当前节点的父节点。
   > 2. 如果父节点是它本身，则该父节点为树的根节点，直接返回；否则返回步骤 1。

2. 并查集合并操作：

   > 1. 分别获得传入的两个节点所在的树的根节点。
   > 2. 如果两个根节点相同说明它们在一棵树上，返回 false，结束合并操作。
   > 3. 如果两个根节点不同，则将其中一个根节点的父指针指向另一个根节点，合并操作完成，返回 true。

3. 并查集按秩合并：

   > 1. 利用一个数组保存每个节点的所在树的节点总数，即保存每个节点的秩。
   > 2. 分别获得传入的两个节点所在的树的根节点。
   > 3. 比较两个根节点是否，相同则返回 false，结束合并操作、
   > 4. 若两个根节点的秩不同，比较他们的秩的大小。
   > 5. 将秩较小的根节点的父指针指向秩较大的跟节点。
   > 6. 更新合并后的根节点的秩，返回 true，结束合并操作。

#### 5.QUICK-FIND 和Quick-Union

 5.1 Quick-find :

​	联通判断复杂度：O(1)

​	合并操作复杂度：O(n)

![1583076624328](/tmp/1583076624328.png)

  5.2 Quick-union : 

​	联通判断：O(logn) tree-height 树高 

​	合并操作：O(logn) tree-height 树高 

  low（i）树高为i的情况下，最少结点数：

​     low（1）= 1， low（2）= 2， low（3） = 4， low（4）= 8，.... , low（h） = 2^(h - 1)

 **假如高度为1 和高度为2的树，合并时会变成高度为2的二叉树,所以高度为3的树应该由两个高度为2的树**

**总结：按节点的数量合并，比较优、快**，是将节点少的合并到节点数多的下边

![1583076576629](/tmp/1583076576629.png)

![1583076723227](/tmp/1583076723227.png)

#### 6. 并查集(Quick-find)的代码：

```C
#include <stdio.h>
#include <stdlib.h>

typedef struct UnionSet {
    int *color;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->color = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->color[i] = i;
    }
    return u;
}

int find(UnionSet *u, int x) {
    return u->color[x];
}

int merge(UnionSet *u, int a, int b) {
    if (find(u, a) == find(u, b)) return 0;
    int color_a = u->color[a];
    for (int i = 1; i <= u->n; i++) {
        if (u->color[i] - color_a) continue;
        u->color[i] = u->color[b];
    }
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->color);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No"); break;
        }
    }
    clear(u);
    return 0;
}
```

#### 7.并查集(Quick-Union)的代码：

```C
#include <stdio.h>
#include <stdlib.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father, *size;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->size = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->father[i] = i;
        u->size[i] = 1;
    }
    return u;
}

int find(UnionSet *u, int x) {
    return u->father[x] = (u->father[x] == x ? x : find(u, u->father[x]));
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    //if (u->size[fa] < u->size[fb]) swap(fa, fb);
    u->father[fb] = fa;
    //u->size[fa] += u->size[fb];
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->father);
    free(u->size);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No"); break;
        }
    }
    clear(u);
    return 0;
}
```

#### 8.并查集总结：

![1583076795883](/tmp/1583076795883.png)

